package com.iweb.test5;

/** volatile
 * 作用
 * 1.保证变量的可见性
 * 2.禁止指令重排序
 *
 * JMM Java内存模型 java虚拟机规范中所定义的一种内存模型
 * 为了屏蔽底层不同的计算机区别
 * 计算机的内存模型 高速缓存 作为内存和CPU之间的缓冲
 * 将运算需要使用到的数据 复制到缓存中 让运算能够快速进行 等运算结束之后
 * 再从缓存中同步回内存中 cpu就不需要再等待内存读写完成之后再继续读写指令了
 *
 * 在多核cpu出现之后 引入了一个新的问题
 * 缓存一致性问题
 * 多cpu系统中 每一个cpu都有一个自己的高速缓存 而所有cpu又共享同一个主内存
 * 必须遵循一个协议 叫做一致性协议
 *
 * JMM内存模型规定 所有的共享变量存储在主内存中 (变量指的是实例变量和类变量 不包含局部变量) 局部变量时线程私有的 不存在竞争关系
 *      每一个线程必须在一个自己的工作内存 线程工作内存保留了被线程所使用的变量的副本
 *      线程对变量的所有操作读写 都必须在工作内存中完成 不可以直接读写主内存中的变量
 *      不同的线程之间也不可以直接访问对方工作内存中的变量 线程之间变量值的传递需要通过主内存中转
 * 解决线程变量可见性问题的方案
 * 1.加锁 某一个线程进入到synchronized 代码块前后 线程会获得锁 会清空工作内存 从主内存拷贝共享变量最新的值到工作内存
 *      中成为符本 继续执行代码 如果对变量值又修改 则将修改后的副本的值写回主内存 操作完成后 线程释放锁
 *      获取不到锁的线程会被阻塞 所以变量的值永远都是新的
 * 2.volatile 每个线程操作数据的时候 会把数据从主内存读取到自己的工作内存 如果线程操作了数据并且写回了
 *      其他已经读取了线程的变量符本就会失效
 *      volatile当一个线程修改了volatile锁修饰的变量 并且将修改写回主线程的时候 另外一个线程会立即看到最新的值
 *
 *
 *
 * 一致性协议 Intel mesi缓存一致性协议
 * MESI 当CPU写入数据的时候 如果发现操作的变量是共享变量(其他CPU中也存在该变量的副本)
 * 会发出信号通知其他CPU将该变量的缓存行设置为无效状态 所以当其他CPU需要读取这个变量的时候
 * 发现自己缓存中缓存该变量的缓存行无效 就会从主内存重新读取
 * 怎么发现数据是否失效？
 * 嗅探 每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是否过期
 * 当处理器发现了自己缓存行对应的内存地址被修改 将会当前处理的缓存行设置为无效状态
 *
 * 嗅探的问题 会产生总线风暴
 * volatile使用的MES的缓存一致性原则 需要不断的从主内存嗅探和cas不断循环去判断缓存值是否失效
 * 会产生大量的总线的无效交互 而总线的带宽是有限的 当总线带宽被嗅探和cas循环耗尽的时候 就会出现总线风暴问题
 * 不要大量使用volatile 避免总线风暴
 *
 * volatile 不能保证数据的安全 本身是没有锁的
 * 一般将volatile加上线程安全(ConcurrentHashMap/AtomicInteger)的操作一起使用
 * @author LYH
 * @date 2023/11/23 20:12
 */
public class Test {
    public static void main(String[] args) {
        LYH l = new LYH();
        l.start();
        while (true){
            if(l.isFlag()){
                System.out.println("发现flag的值变化了");
                break;
            }
        }
    }
}
