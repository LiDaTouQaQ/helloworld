package com.iweb.test4;

/** java 中的内存分配
 * 直接内存 为NIO通信进行使用的
 * 运行时内存
 * > 方法区
 *      > 运行时常量池
 * > 堆
 * > 程序计数器
 * > 本地方法栈
 * > 虚拟机栈
 *
 * 线程共享内存区域 方法区 堆 直接内存 运行时常量池
 * 线程私有内存区域 程序计数器 本地方法栈 虚拟机栈
 *
 * 各个内存空间的作用
 * 堆: 存放对象
 * 程序计数器: 每一个线程私有的 记录的是线程所运行到的代码的行号(运行到代码所对应的内存地址)
 * 方法区: 线程共享的内存区域 方法区中存放的是每一个类的相关信息 包括类的名称 方法的具体信息 成员变量的具体信息
 *          静态变量 常量 以及编译器编译之后所生成的字节码文件
 *          其中还包含一个特殊的 运行时常量池 用来存储编译期间类生成的字面量和符号引用
 *          在类或者接口被加载到jvm之后 接口和类所对应的运行时常量池就会被自动创建
 * 直接内存: 不属于运行时内存，性能高 不会受到Java堆大小的限制 通常用用于NIO做数据通信
 * 本地方法栈: 为所有native所修饰的方法服务的
 * 虚拟机栈: 方法被线程调用之后 会生成栈帧 最先被调用的方法对应的栈帧最后出栈
 *          虚拟机栈中的存储 五个部分
 *            局部变量表: 用来存方法中的局部变量(包括方法中定义参数以及声明的非静态变量)
 *              对于基本数据类型的变量 直接存储值 对于引用类型的变量存放其指向对象所对应的内存地址
 *              局部变量表的大小在编译期间就已经确定了
 *            操作数栈: 一个线程在执行方法的过程中 本质上是不断执行语句的过程 也是执行计算的过程
 *              程序中所有的计算过程都是借助于操作数栈完成的
 *            指向运行时常量池的引用: 方法在执行的过程中可能会需要用到类中的常量 所以必须要保存一个引用
 *              来指向目标的运行时常量池
 *            方法的返回地址: 方法在执行完成之后 如果有return 需要将运行时结果返回给调用方法的地方
 *              所以栈帧中必须保存一个方法的返回地址
 *            附加信息
 * @author LYH
 * @date 2023/11/23 19:46
 */
public class Test {
}
